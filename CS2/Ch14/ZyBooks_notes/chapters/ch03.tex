\chapter{Recursive Algorithm: Search}

\section*{From Repetition to Strategy}
Loops and recursion both repeat workâ€”but recursion lets us do it *intelligently*.  
Instead of plowing through every item one by one, a recursive algorithm can **divide and conquer**.

A recursive algorithm breaks a problem into smaller, self-similar versions of itself until the smallest case (the *base case*) can be solved directly.

\section{A Familiar Analogy: The Guessing Game}
Imagine your friend thinks of a number between 0 and 100.  
Each time you guess, your friend says "higher" or "lower."  

If you always guess halfway between the possible range, youâ€™ll find the number in about $\log_2(100) \approx 7$ guesses.

Thatâ€™s **binary search**â€”recursion in action.

\begin{lstlisting}[language=Python, caption={Recursive binary search for a number}]
def binary_search(low, high, target):
    if low > high:
        print("Not found!")
        return
    mid = (low + high) // 2
    print(f"Searching {low}..{high} (mid={mid})")
    if mid == target:
        print("Found it!")
    elif target < mid:
        binary_search(low, mid - 1, target)
    else:
        binary_search(mid + 1, high, target)

binary_search(0, 100, 32)
\end{lstlisting}

\noindent
This algorithm is recursive because it calls itself on smaller subranges each time.  
When the range collapses (\texttt{low > high}), the function ends.

\begin{quote}
Every recursive algorithm is a conversation with smaller versions of itself.
\end{quote}

\section{Recursive Search in a Sorted List}
Now letâ€™s find a name in a list thatâ€™s alphabetically sorted.  
This is a textual version of binary search.

\begin{lstlisting}[language=Python, caption={Recursive search in a sorted list}]
def find(lst, item, low, high):
    if low > high:
        return -1  # Not found
    mid = (low + high) // 2
    if lst[mid] == item:
        return mid
    elif item < lst[mid]:
        return find(lst, item, low, mid - 1)
    else:
        return find(lst, item, mid + 1, high)

names = ["Adams, Mary", "Carver, Michael", "Domer, Hugo",
         "Fredericks, Carlo", "Liu, Jie"]

person = input("Enter last, first: ")
pos = find(names, person, 0, len(names) - 1)
if pos >= 0:
    print(f"Found {person} at index {pos}")
else:
    print("Not found.")
\end{lstlisting}

\noindent
Notice how the search range shrinks by half each time.  
Recursive binary search is powerful because it eliminates half the data at every step.

\section{Thinking Recursively}
A recursive algorithm always has these three traits:
\begin{enumerate}
    \item \textbf{A clear goal:} What are we trying to find?
    \item \textbf{A base case:} When do we stop searching?
    \item \textbf{A recursive case:} How do we break the problem into smaller ones?
\end{enumerate}

Youâ€™ll see this pattern everywhereâ€”from sorting algorithms (quicksort, mergesort)  
to tree traversal and directory searches.

\section{Visualizing the Divide-and-Conquer Pattern}
Each recursive call creates a branch in the "decision tree."  
Hereâ€™s the mental image:

\begin{verbatim}
Search [0..100]
 |- Guess 50 -> too high -> Search [0..49]
 |   |- Guess 25 -> too low -> Search [26..49]
 |   |   |- Guess 37 -> too high -> Search [26..36]
 |   |   |   |- Guess 31 -> too low -> Search [32..36]
 |   |   |   |   |- Guess 34 -> Found!
\end{verbatim}

\noindent
Each level of recursion focuses on a smaller search space.  
The call stack keeps track of where you came from.

\section{Tracing the Call Stack}
When recursion runs, Python keeps track of every unfinished call in the *call stack*.  
Think of it as a trail of sticky notesâ€”each one says, â€œCome back to me when youâ€™re done.â€

\begin{verbatim}
binary_search(0, 100, 32)
  â”œâ”€â”€ binary_search(0, 49, 32)
  â”œâ”€â”€ binary_search(25, 49, 32)
  â”œâ”€â”€ binary_search(32, 36, 32)
  â””â”€â”€ Found!
\end{verbatim}

Each time the recursive call returns, Python pops one frame off the stack.  
When the base case is reached, the stack empties gracefully.  
If you forget your base caseâ€”well, Python keeps stacking until it crashes! ğŸ˜…

\section{Try It Yourself}
Write your own recursive search for these problems:
\begin{enumerate}
    \item Search for a letter in a string, returning its index.
    \item Search for the smallest number in a sorted list (without using \texttt{min()}).
    \item Modify \texttt{find()} to print the number of recursive calls made.
\end{enumerate}

\section*{Challenge: Recursive Word Finder}
For extra fun, try writing a recursive function that searches through nested lists:
\begin{lstlisting}[language=Python, caption={Recursive word finder challenge}]
def find_word(nested_list, word):
    for item in nested_list:
        if isinstance(item, list):
            if find_word(item, word):
                return True
        elif item == word:
            return True
    return False

data = [["dog", ["cat", "fish"]], ["hamster", ["parrot", "snake"]]]
print(find_word(data, "snake"))  # True
print(find_word(data, "whale"))  # False
\end{lstlisting}

\noindent
This shows recursion applied to hierarchical dataâ€”a natural fit when structures contain smaller versions of themselves.

\section*{Closing Thought}
Recursive search is not just fasterâ€”itâ€™s smarter.  
It doesnâ€™t look at everything; it looks *strategically*.  
Thatâ€™s what separates **repetition** from **recursion**â€”and **recursion** from **algorithmic thinking**.

\begin{center}
\textit{Next: Debugging recursive calls â€” the art of seeing the invisible stack.}
\end{center}

