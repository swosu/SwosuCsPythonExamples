\chapter{The Fibonacci Sequence -- Nature's Algorithm | Teacher's Commentary}
\label{ch:fibonacci-solution}

\section{The Story Beneath the Spiral}

The Fibonacci sequence is where mathematics stops being a cold ledger and begins
to hum.  It is the pattern that flowers whisper and pinecones carve; it is the
mathematical heartbeat of reproduction, rhythm, and recursion.

Begin your lesson by asking: \emph{What does it mean for something to build
itself from itself?}  Let students suggest everyday examples—stories that fold
back, family trees, mirrors, Russian nesting dolls.  This primes the recursive
intuition before a single formula is written.

\begin{quote}
\textbf{Pedagogical hint:} Treat Fibonacci not as a new sequence, but as the
first time the students meet a truly self-referential idea in code.
\end{quote}

\section{Seeing the Pattern Emerge}

Start with the simple rule:
\[
F(n) = F(n-1) + F(n-2), \quad F(0)=0, \; F(1)=1.
\]

Ask them to compute $F(2)$, $F(3)$, $F(4)$ by hand on the board.
Then quietly step aside and let the pattern take over.  The delight comes from
watching the class realize they can keep going forever, but also that every new
term depends on the last two—the past always haunts the future.

\begin{quote}
\textbf{Common misconception:}
Students often believe that each term is computed once.  In the recursive
version, it isn’t!  Highlight that every call to \texttt{fib(n)} may re-summon
its siblings many times.
\end{quote}

\section{A Gentle Python Beginning}

Transition into code gently.  Begin with the most human expression of
recursion—a definition that reads like English.

\begin{lstlisting}[language=Python,caption={Naive Fibonacci definition}]
def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)
\end{lstlisting}

Invite them to trace \texttt{fib(5)}.  Encourage sketching a recursion tree on
the whiteboard.  Each branch is a call; each leaf a base case.  This is where
students begin to \emph{see} recursion rather than merely compute it.

\begin{quote}
\textbf{Teaching tip:}
Ask the class: “If we could hear the computer think, what would this sound
like?”  The answer: a chorus of overlapping echoes.
\end{quote}

\section{Counting the Chaos}

Introduce a counting function that measures how many recursive calls occur.

\begin{lstlisting}[language=Python,caption={Instrumented Fibonacci counter}]
calls = 0

def fib_count(n):
    global calls
    calls += 1
    if n <= 1:
        return n
    else:
        return fib_count(n-1) + fib_count(n-2)

calls = 0
fib_count(10)
print("Total calls:", calls)
\end{lstlisting}

Have students predict before running.  Most guess “maybe 10 or 20.”  The real
answer—\texttt{177}—usually triggers laughter and disbelief.  This is where
Big-$O$ starts to feel real.

\begin{quote}
\textbf{Discussion prompt:}
How does this explosion relate to the branches of the recursion tree?  
Which values are recomputed?  How could we prevent that?
\end{quote}

\section{The Moment of Memoization}

Before revealing the fix, invite a student to guess how the computer might
“remember” prior results.  Then, introduce memoization as a form of
\emph{memory with manners}—a polite way for a function to say, “Oh wait, I’ve
done that already.”

\begin{lstlisting}[language=Python,caption={Memoized Fibonacci}]
memo = {0: 0, 1: 1}

def fib_memo(n):
    if n not in memo:
        memo[n] = fib_memo(n-1) + fib_memo(n-2)
    return memo[n]
\end{lstlisting}

Ask the class to predict how many calls this version makes for \texttt{n=30}.
Then run it—only 59!  The algorithm now feels like a wise old sage: still
recursive, but reflective.

\section{Reflection and Connection}

Bring the conversation back to nature: how leaves, shells, and pinecones follow
Fibonacci because growth builds upon growth.  The algorithm’s
\emph{mathematical economy} mirrors biological efficiency.

\begin{quote}
\textbf{Teaching insight:}
Recursion is not just a technique—it’s a philosophy.
Every complex system that repeats patterns of its past to create its future is
recursive in spirit.
\end{quote}

\section{Bridging to the Next Chapter}

Close by preparing them for Chapter~\ref{ch:measuring-recursion-solution},
where they will measure recursion’s cost.

Give them a final experiment:
\begin{itemize}
  \item Run both \texttt{fib(30)} and \texttt{fib\_memo(30)}.
  \item Compare the time difference.
  \item Discuss which grows faster and why.
\end{itemize}

Encourage curiosity: “What if we plotted the number of calls vs.~$n$?  What
shape would it form?”  (Answer: an exponential mountain for naive recursion, a
gentle hill for memoization.)

\section{Teacher’s Reflection}

\begin{quote}
\textbf{Mantra:} Teach recursion as poetry first, algorithm later.
\end{quote}

Students remember stories longer than syntax.  
Fibonacci is your gateway to the emotional side of algorithms—a reminder that
patterns can be both efficient and beautiful.

End this lesson with the story of rabbits, or with the sunflower’s spiral.
Smile, because the math itself is smiling back.

