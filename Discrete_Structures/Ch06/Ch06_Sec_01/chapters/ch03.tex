\chapter{Section 6.1 — Extended Product Rule}

\section{The Extended Product Rule}

The basic product rule can be generalized to any number of sequential tasks.  
Suppose a procedure consists of tasks $T_1, T_2, \ldots, T_m$, where each task $T_i$ can be completed in $n_i$ ways,  
independent of how the earlier tasks were done.  
Then the entire procedure can be performed in

\[
n_1 \times n_2 \times \cdots \times n_m.
\]

This can be proven formally by mathematical induction on the number of tasks—an idea that connects back beautifully to Chapter~5 on induction and recursion.

\section{Worked Examples}

\begin{example}[Bit Strings of Length Seven]
How many different bit strings of length seven are there?

\begin{solution}
Each of the seven bits can be chosen in two ways—either 0 or 1.  
By the product rule, the total number of bit strings is:
\[
2^7 = 128.
\]
\end{solution}
\end{example}

\begin{example}[License Plates]
How many different license plates can be made if each contains three uppercase English letters followed by three digits?

\begin{solution}
There are $26$ choices for each of the three letters and $10$ choices for each of the three digits:
\[
26^3 \times 10^3 = 17{,}576{,}000.
\]
So there are $17{,}576{,}000$ possible license plates.
\end{solution}
\end{example}

\begin{example}[Counting Functions]
How many functions exist from a set with $m$ elements to a set with $n$ elements?

\begin{solution}
Each element of the domain can be mapped to any of the $n$ elements in the codomain.  
Thus, by the product rule:
\[
n^m \text{ functions.}
\]
For instance, there are $5^3 = 125$ functions from a three-element set to a five-element set.
\end{solution}
\end{example}

\begin{example}[Counting One-to-One Functions]
How many one-to-one (injective) functions exist from a set with $m$ elements to a set with $n$ elements?

\begin{solution}
If $m>n$, none exist.  
When $m \leq n$, the first element can map to any of $n$ values,  
the next to $(n-1)$ remaining values, and so on, giving:
\[
n(n-1)(n-2)\cdots(n-m+1).
\]
For example, from a three-element set to a five-element set:
\[
5\times4\times3 = 60.
\]
\end{solution}
\end{example}

\section{Apply It Yourself}

\subsection*{Warm-Up Problem}

How many different bit strings of length eight are there?

\newpage
\textbf{Solution:}  
Each bit can be either 0 or 1, so there are $2^8 = 256$ possible bit strings.

\bigskip

\subsection*{Practice Problem 1 — Easier}

How many license plates can be made if each plate has two uppercase English letters followed by two digits?

\newpage
\textbf{Solution:}  
Each of the two letters has 26 possibilities, and each digit has 10:
\[
26^2 \times 10^2 = 67{,}600.
\]
Thus, there are $67{,}600$ unique plates.

\bigskip

\subsection*{Practice Problem 2 — Moderate}

How many one-to-one functions are there from a set with four elements to a set with six elements?

\newpage
\textbf{Solution:}  
\[
6 \times 5 \times 4 \times 3 = 360.
\]
There are $360$ one-to-one functions.

\bigskip

\subsection*{Practice Problem 3 — Challenging}

How many functions exist from a set with $m=10$ elements to a set with $n=3$ elements?  
How many of these are one-to-one?

\newpage
\textbf{Solution:}  
\begin{itemize}
  \item Total functions: $3^{10} = 59{,}049$.
  \item One-to-one functions: none, since $m>n$.
\end{itemize}

\bigskip

\subsection*{Practice Problem 4 — Stretch Challenge}

A company issues employee IDs consisting of:  
two uppercase letters, followed by one of five department codes (A–E), followed by a 3-digit number (000–999).  
How many possible IDs can be created?

\newpage
\textbf{Solution:}  
\[
26^2 \times 5 \times 1000 = 3{,}380{,}000.
\]
So there are $3{,}380{,}000$ unique ID numbers possible.

\section{Python Demonstrations}

Below is Python code that illustrates these calculations.  
It emphasizes how the product rule scales as more tasks are added.

\begin{lstlisting}[language=Python, caption={Extended Product Rule Examples}]
"""
COMSC 2043 - Extended Product Rule Demonstrations
Author: Jeremy Evert
"""

from math import prod

def bit_strings(n):
    return 2 ** n

def license_plates(letters, digits):
    return 26 ** letters * 10 ** digits

def functions(m, n):
    return n ** m

def one_to_one_functions(m, n):
    if m > n:
        return 0
    choices = [n - i for i in range(m)]
    return prod(choices)

def main():
    print("=== Extended Product Rule ===\n")
    print(f"Bit strings of length 7: {bit_strings(7)}")
    print(f"License plates (3 letters, 3 digits): {license_plates(3, 3):,}")
    print(f"Functions from 3->5: {functions(3,5)}")
    print(f"One-to-one from 3->5: {one_to_one_functions(3,5)}")
    print(f"Warm-up (8-bit strings): {bit_strings(8)}")
    print(f"Practice 1 (2 letters, 2 digits): {license_plates(2,2):,}")
    print(f"Practice 2 (one-to-one 4->6): {one_to_one_functions(4,6)}")
    print(f"Practice 3 (functions 10->3): {functions(10,3)} | one-to-one: {one_to_one_functions(10,3)}")
    print(f"Practice 4 (employee IDs): {26**2 * 5 * 1000:,}")
    print("\nDone!")

if __name__ == "__main__":
    main()
\end{lstlisting}

\section*{Reflection}

The extended product rule shows how independence and sequence multiply possibilities.  
The pattern $n_1n_2\cdots n_m$ appears everywhere—from network addressing and password generation to database schema design and combinatorial search.  
Every time we build loops or nested conditionals in code, we are implicitly applying the same principle.
