\chapter{Section 6.1 — Extended Product Rule}

\section{The Extended Product Rule}

The basic product rule can be generalized to any number of sequential tasks.  
Suppose a procedure consists of tasks $T_1, T_2, \ldots, T_m$, where each task $T_i$ can be completed in $n_i$ ways,  
independent of how the earlier tasks were done.  
Then the entire procedure can be performed in

\[
n_1 \times n_2 \times \cdots \times n_m.
\]

This generalization is called the \textbf{Extended Product Rule}.  
It can even be proven formally using mathematical induction on the number of tasks—an idea that connects beautifully to Chapter~5 on induction and recursion.

\bigskip
In essence, when tasks are independent and sequential, the total number of possible outcomes is the product of the possibilities for each step.

\section{Worked Examples}

The following examples illustrate how the extended product rule applies in both mathematics and computer science.

\begin{example}[Bit Strings of Length Seven]
How many different bit strings of length seven are there?

\textbf{Solution.}  
Each of the seven bits can be chosen in two ways—either 0 or 1.  
By the product rule, the total number of bit strings is:
\[
2^7 = 128.
\]
\end{example}

\begin{example}[License Plates]
How many different license plates can be made if each contains three uppercase English letters followed by three digits?

\textbf{Solution.}  
There are $26$ choices for each of the three letters and $10$ choices for each of the three digits:
\[
26^3 \times 10^3 = 17{,}576{,}000.
\]
So there are $17{,}576{,}000$ possible license plates.
\end{example}

\begin{example}[Counting Functions]
How many functions exist from a set with $m$ elements to a set with $n$ elements?

\textbf{Solution.}  
Each element of the domain can be mapped to any of the $n$ elements in the codomain.  
Thus, by the product rule:
\[
n^m \text{ functions.}
\]
For instance, there are $5^3 = 125$ functions from a three-element set to a five-element set.
\end{example}

\begin{example}[Counting One-to-One Functions]
How many one-to-one (injective) functions exist from a set with $m$ elements to a set with $n$ elements?

\textbf{Solution.}  
If $m>n$, none exist.  
When $m \leq n$, the first element can map to any of $n$ values,  
the next to $(n-1)$ remaining values, and so on, giving:
\[
n(n-1)(n-2)\cdots(n-m+1).
\]
For example, from a three-element set to a five-element set:
\[
5\times4\times3 = 60.
\]
\end{example}

\section{Apply It Yourself}

Try these practice problems to reinforce the rule.  
Each one extends the pattern of independent sequential choices.

\subsection*{Warm-Up Problem}

How many different bit strings of length eight are there?

\textbf{Solution.}  
Each bit can be either 0 or 1, so there are $2^8 = 256$ possible bit strings.

\bigskip

\subsection*{Practice Problem 1 — Easier}

How many license plates can be made if each plate has two uppercase English letters followed by two digits?

\textbf{Solution.}  
Each of the two letters has 26 possibilities, and each digit has 10:
\[
26^2 \times 10^2 = 67{,}600.
\]
Thus, there are $67{,}600$ unique plates.

\bigskip

\subsection*{Practice Problem 2 — Moderate}

How many one-to-one functions are there from a set with four elements to a set with six elements?

\textbf{Solution.}  
\[
6 \times 5 \times 4 \times 3 = 360.
\]
There are $360$ one-to-one functions.

\bigskip

\subsection*{Practice Problem 3 — Challenging}

How many functions exist from a set with $m=10$ elements to a set with $n=3$ elements?  
How many of these are one-to-one?

\textbf{Solution.}  
\begin{itemize}
  \item Total functions: $3^{10} = 59{,}049$.
  \item One-to-one functions: none, since $m>n$.
\end{itemize}

\bigskip

\subsection*{Practice Problem 4 — Stretch Challenge}

A company issues employee IDs consisting of two uppercase letters,  
followed by one of five department codes (A–E),  
followed by a 3-digit number (000–999).  
How many possible IDs can be created?

\textbf{Solution.}  
\[
26^2 \times 5 \times 1000 = 3{,}380{,}000.
\]
So there are $3{,}380{,}000$ unique ID numbers possible.

\section{Python Demonstrations}

Let's express the same reasoning in Python.  
The following script illustrates how the extended product rule scales as the number of independent tasks grows.

\begin{lstlisting}[language=Python, caption={Extended Product Rule Examples}]
"""
COMSC 2043 - Extended Product Rule Demonstrations
Author: Jeremy Evert
"""

from math import prod

def bit_strings(n):
    return 2 ** n

def license_plates(letters, digits):
    return 26 ** letters * 10 ** digits

def functions(m, n):
    return n ** m

def one_to_one_functions(m, n):
    if m > n:
        return 0
    choices = [n - i for i in range(m)]
    return prod(choices)

def main():
    print("=== Extended Product Rule ===\n")
    print(f"Bit strings of length 7: {bit_strings(7)}")
    print(f"License plates (3 letters, 3 digits): {license_plates(3, 3):,}")
    print(f"Functions from 3->5: {functions(3,5)}")
    print(f"One-to-one from 3->5: {one_to_one_functions(3,5)}")
    print(f"Warm-up (8-bit strings): {bit_strings(8)}")
    print(f"Practice 1 (2 letters, 2 digits): {license_plates(2,2):,}")
    print(f"Practice 2 (one-to-one 4->6): {one_to_one_functions(4,6)}")
    print(f"Practice 3 (functions 10->3): {functions(10,3)} | one-to-one: {one_to_one_functions(10,3)}")
    print(f"Practice 4 (employee IDs): {26**2 * 5 * 1000:,}")
    print("\nDone!")

if __name__ == "__main__":
    main()
\end{lstlisting}

\section*{Reflection}

The extended product rule shows how independence and sequence multiply possibilities.  
The pattern $n_1 n_2 \cdots n_m$ appears everywhere—from network addressing and password generation  
to database schema design and combinatorial search.  
Every time we build loops or nested conditionals in code, we are implicitly applying this same principle.

\paragraph{Key Takeaway.}
Each new layer of choice multiplies the universe of outcomes.  
Recognizing independence is the key to mastering both counting and algorithmic reasoning.

\section*{Next Steps}

In the next chapter, we’ll watch the product rule come alive in real systems—  
from telephone numbers and nested loops to subsets and combinatorial trees—  
as we explore \textbf{The Product Rule in Action}.

