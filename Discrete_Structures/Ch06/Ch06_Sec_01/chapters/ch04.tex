\chapter{Section 6.1 — Product Rule in Action}

\section{Real-World Applications of the Product Rule}

Counting problems appear everywhere—from numbering systems to programming loops and data structures.  
The product rule quietly powers many of the systems we rely on every day.  
Let’s see how it works in the wild.

\section{Example 1 — The North American Telephone Numbering Plan}

The North American Numbering Plan (NANP) defines 10-digit phone numbers,  
split into a three-digit \emph{area code}, a three-digit \emph{office code}, and a four-digit \emph{station code}.  

\begin{itemize}
  \item $N$: any digit from 2–9  
  \item $Y$: either 0 or 1  
  \item $X$: any digit from 0–9
\end{itemize}

\textbf{Old Plan (NYX–NNX–XXXX):}
\[
\begin{aligned}
\text{Area codes: } &8 \times 2 \times 10 = 160,\\
\text{Office codes: } &8 \times 8 \times 10 = 640,\\
\text{Station codes: } &10^4 = 10{,}000.
\end{aligned}
\]
Total: $160 \times 640 \times 10{,}000 = 1.024\times10^9$ phone numbers.

\textbf{New Plan (NXX–NXX–XXXX):}
\[
\begin{aligned}
\text{Area codes: } &8 \times 10 \times 10 = 800,\\
\text{Office codes: } &8 \times 10 \times 10 = 800,\\
\text{Station codes: } &10^4 = 10{,}000.
\end{aligned}
\]
Total: $800 \times 800 \times 10{,}000 = 6.4\times10^9$ phone numbers.

\begin{solution}
The new plan increases capacity by a factor of about six.  
A small rule change leads to billions more combinations—combinatorics in action.
\end{solution}

\subsection*{Practice Problems}

\textbf{1. Easier.}  
A small town uses 7-digit numbers in the format NXX–XXX,  
where $N$ is from 2–9 and $X$ is from 0–9.  
How many phone numbers can be issued?

\textbf{Solution.}  
\[
8 \times 10^5 = 8{,}000{,}000.
\]

\textbf{2. Moderate.}  
If the first two digits must be odd (1, 3, 5, 7, 9), how many numbers exist?

\textbf{Solution.}  
\[
5 \times 5 \times 10^5 = 2{,}500{,}000.
\]

\textbf{3. Stretch.}  
If each number begins with one of 26 region letters (A–Z),  
how many distinct identifiers exist?

\textbf{Solution.}  
\[
26 \times 8{,}000{,}000 = 208{,}000{,}000.
\]

\section{Example 2 — Counting Nested Loops}

Programmers apply the product rule constantly, often without realizing it.  
Consider the pseudocode:

\begin{lstlisting}[language=Python]
k = 0
for i1 in range(1, n1+1):
    for i2 in range(1, n2+1):
        ...
        for im in range(1, nm+1):
            k += 1
\end{lstlisting}

Each loop represents one “task” $T_i$ with $n_i$ iterations.  
By the product rule, the innermost statement executes:
\[
n_1 \times n_2 \times \cdots \times n_m
\]
times, so the final value of $k$ is exactly that product.

\subsection*{Practice Problems}

\textbf{1. Easier.}  
If the outer loop runs 5 times and the inner loop 4 times, how many increments occur?  
\[
5 \times 4 = 20.
\]

\textbf{2. Moderate.}  
For three nested loops running 3, 4, and 2 times respectively:  
\[
3 \times 4 \times 2 = 24.
\]

\textbf{3. Stretch.}  
Write a Python function that computes $k$ automatically for any sequence $(n_1,n_2,\ldots,n_m)$.

\begin{lstlisting}[language=Python]
from math import prod
def nested_loops(*sizes):
    return prod(sizes)
print(nested_loops(3, 4, 2))  # Output: 24
\end{lstlisting}

\section{Example 3 — Counting Subsets of a Finite Set}

Use the product rule to show that a set $S$ with $|S|=n$ has $2^n$ subsets.

\textbf{Solution.}  
For each element of $S$, we make two independent choices:
\begin{enumerate}
  \item include it in the subset, or
  \item exclude it.
\end{enumerate}

Each of the $n$ choices has two outcomes, producing:
\[
2^n \text{ total subsets.}
\]
Each subset corresponds to a unique bit string of length $n$—a binary fingerprint of membership.

\subsection*{Practice Problems}

\textbf{1. Easier.}  
How many subsets does $\{a,b,c\}$ have?  
\[
2^3 = 8.
\]

\textbf{2. Moderate.}  
If $|S| = 10$, how many subsets contain at least one element?  
\[
2^{10} - 1 = 1023.
\]

\textbf{3. Stretch.}  
How many subsets of a set with $n$ elements have exactly $k$ members?  
\[
\binom{n}{k}.
\]

\section{Python Demonstrations}

\begin{lstlisting}[language=Python, caption={Counting with Loops and Sets}]
from itertools import chain, combinations
from math import prod

# Telephone numbering comparison
def phone_numbers(area, office, station):
    return area * office * station

print("Old plan:", phone_numbers(160, 640, 10_000))
print("New plan:", phone_numbers(800, 800, 10_000))

# Nested loop counter
def nested_count(*sizes):
    return prod(sizes)

print("Nested loop 3x4x2:", nested_count(3,4,2))

# Subsets demonstration
S = {'a', 'b', 'c'}
power_set = list(chain.from_iterable(combinations(S, r) for r in range(len(S)+1)))
print("Subsets of {a,b,c}:", power_set)
print("Count:", len(power_set))
\end{lstlisting}

\section*{Reflection}

The product rule connects telephone networks, program loops, and the logic of sets.  
Each system multiplies independent possibilities, revealing how small rules create enormous complexity.  

In computer science, this principle hides in plain sight:  
every nested loop, every binary decision, every permutation generator is a quiet tribute to the power of multiplication.

\section*{Next Steps}

In the next chapter, we turn to the other side of counting—  
where overlap, exclusion, and repetition break independence—  
and discover the elegance of the \textbf{Sum and Subtraction Rules}.

