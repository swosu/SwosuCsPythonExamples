\chapter{Memory Allocation and Garbage Collection}
\label{ch:memory_allocation_and_garbage_collection}

\section{9.10 Memory Allocation and Garbage Collection}

\subsection*{Memory Allocation}

The process of an application requesting and being granted memory is called
\textbf{memory allocation}.  
When a Python program runs, it requests memory from the operating system.
Python’s runtime then divides that memory into sections for code, data, and dynamically
created objects.

While some languages require programmers to manage memory manually,
Python automatically allocates and releases memory on the programmer’s behalf.

\begin{lstlisting}[language=Python, caption={Memory allocation in Python}]
lst = []
for i in range(0, 100):
    lst.append(i)
print("List length:", len(lst))
\end{lstlisting}

When the list \texttt{lst} is created, Python requests space for it from the operating
system. As more elements are appended, the interpreter automatically allocates additional
blocks of memory as needed.

\textbf{Key Points}
\begin{itemize}
  \item System memory is divided into segments managed by the OS.
  \item Python applications request memory through the interpreter, not directly.
  \item Other processes may occupy different regions of memory simultaneously.
  \item Allocation is usually invisible to the programmer.
\end{itemize}

\begin{quote}
\textbf{Instructor Note:} Emphasize that memory allocation happens behind the scenes.
The programmer writes code that creates objects—Python handles where and how they live.
\end{quote}

\subsection*{Quick Check}

\begin{enumerate}
  \item The Python runtime requests memory from the operating system. \textbf{(True)}
  \item Objects may reside in memory that has not been allocated. \textbf{(False)}
  \item All programming languages perform memory allocation for the programmer. \textbf{(False)}
\end{enumerate}

---

\subsection*{Garbage Collection}

\textbf{Memory deallocation} is the act of freeing memory that stores variables or objects
that are no longer needed.  
Python uses a managed model: when objects are no longer referenced by any variable, they
become candidates for automatic removal by the \textbf{garbage collector}.

Each object in memory maintains a \textbf{reference count} (RC)---the number of variables
that reference it. When an object's RC becomes~0, Python knows it can reclaim that space.

\begin{lstlisting}[language=Python, caption={Reference counting in Python}]
string1 = "Python"
string2 = "Computer science"
string3 = string2
string1 = "ZyBooks"
string2 = string1
\end{lstlisting}

Explanation:
\begin{itemize}
  \item Initially, \texttt{string1} references ``Python''.
  \item \texttt{string2} and \texttt{string3} reference ``Computer science''.
  \item Reassigning \texttt{string1} to ``ZyBooks'' makes ``Python'' unreachable.
        Its reference count drops to~0 and it can be deallocated.
\end{itemize}

\begin{quote}
\textbf{Instructor Note:} Demonstrate using a small live example or a diagram to show how
reference counts change as variables are reassigned.
\end{quote}

\textbf{True/False Practice}
\begin{enumerate}
  \item An object with RC~=~0 can be deallocated by the garbage collector. \textbf{True}
  \item Deallocation happens immediately when RC drops to~0. \textbf{False}
  \item Swapping two variables may briefly create an object with RC~=~0. \textbf{True}
\end{enumerate}

---

\subsection*{Reflection}

\begin{itemize}
  \item Why does Python use automatic garbage collection?
  \item How does reference counting prevent memory leaks?
  \item What is one situation where garbage collection might not occur immediately?
\end{itemize}

\begin{quote}
\textbf{Summary:}  
Python automates both allocation and deallocation of memory.
Objects are stored only as long as they are referenced, allowing developers to focus on
logic rather than low-level memory management.
\end{quote}

